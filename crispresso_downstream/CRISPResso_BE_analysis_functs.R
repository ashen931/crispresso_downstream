#CRISPResso_BE_analysis_functs.R
# conda_environment: crispresso_downstream_env
# last modified: 2020_08_17 Anne Shen
# For use with CRISPResso version 2.0.40
#
###  Dependencies:
# library(tidyselect)
# library(tidyverse)
# library(RColorBrewer)
# library(grid)
# options(scipen=999) #turn off scientific notation
#
### Functions:
# get_BE_summary_tb()
# extract_real_be_results()
# extract_real_indels()
# extract_real_be_and_indels()



###### get_BE_summary_tb() #############################################################################
# For CRISPResso2 outputs from base editor samples. Assumes the CRISPResso quantification window
# covers the entire spacer sequence.
# This function takes a list of "_all_[percent_cutoff].csv" summary allele tables and a data column 
# identifier and filters out likely sequencing errors (allows user to set acceptable BE and indel 
# quantification windows).
#
# ARGUMENTS:  summary_file = list of summary files ("_all_[percent_cutoff].csv")
#             dataID = string idenitfier in the sample names that identifies a column as a column of 
#                      allele frequencies
#             ref_nucleotide = nucleotide targeted by BE conversion (ex. C)
#             target_nucleotides = nucleotide(s) generated by BE (no separators, ex. ATCG)
#             base_edit_window = base editing quantification window by hyphen (first bp of guide is index 1)
#             indel_window = indel quantification window joined by hyphen (first bp of guide is index 1)
#
# OUTPUT: none (directly saves summary tables to .csv files in current directory)
get_BE_summary_tb <- function(summary_files, dataID, percent_freq_cutoff, ref_nucleotide, target_nucleotides,
                              base_edit_window, indel_window){
  
  # tester 
  #setwd("/Users/anneshen/Documents/local_working/local_Jing_BE/2020_1620_BE_NatureMed/20200810_BE_1620_rhAMPSeq_v2_0_40")
  # setwd("/Users/anneshen/Documents/local_working/local_Jing_BE/2020_1620_BE_NatureMed/20191206_1620_input_rhAMPSeq_integrated3")
  # summary_files <- list.files(path = ".", pattern = "collapse")
  # dataID <- "1620"
  # percent_freq_cutoff <- 0
  # ref_nucleotide <- "C"
  # target_nucleotides <- "T"
  # base_edit_window <- "3-10"
  # indel_window <- "17-18"
  
  #generate analysis log
  cat("BaseEdit_summary_log\n",
      paste(Sys.time(), "\n", sep = ""),
      paste(getwd(), "\n", sep = ""),
      "dataID: ", dataID, "\n",
      "percent_freq_cutoff: ", percent_freq_cutoff, "\n",
      "ref_nucleotide: ", ref_nucleotide, "\n",
      "target_nucleotide(s): ", target_nucleotides, "\n",
      "base_edit_window: ", base_edit_window, "\n",
      "indel_window: ", indel_window, "\n",
      "\n",
      "Summarizing...\n\n")

  #generate regular expressions for base edit searches (ex. "C[3-9]{1}[ATCG]")
  real_be_regexpr <- paste(ref_nucleotide, "[0-9]{1,}[", target_nucleotides, "]", sep = "")
  
  #get base editing and indel bp index ranges
  base_edit_range <- as.numeric(unlist(str_split(base_edit_window, "-")))
  indel_range <- as.numeric(unlist(str_split(indel_window, "-")))
  
  for(n in seq(1,length(summary_files))){

    #get csv_prefix for saving file
    csv_prefix <- sub(paste("_collapsed_", percent_freq_cutoff, ".csv", sep = ""), "", summary_files[n])
    
    #cat in log file
    cat(csv_prefix, "\n")
    
    #read in summary file
    summary_table <- read.csv(summary_files[n], check.names = FALSE, stringsAsFactors = FALSE)
    
    #initialize edits tracking vector
    edited_alleles <- c()
    
    #### Filter for "correct" base edits (only) and collapse by substitution 
    real_be_only_tb <- summary_table %>% 
      filter((grepl(real_be_regexpr, summary_table$indel)) & 
               !grepl("[+,-]", summary_table$indel))
    
    #extract the "real" base edits and format the indel column
    real_be_tb <- extract_real_be_results(real_be_only_tb, base_edit_range, real_be_regexpr)
    
    real_be_tb <- real_be_tb %>%
      transform(indel = real_be) %>%
      filter(grepl(ref_nucleotide, indel)) %>%
      select(-c("real_be", "potential_be", "be_idx", "real_be_idx"))
    
    #collapse alleles by indel
    if(nrow(real_be_tb) > 0){
      real_be_tb <- collapse_duplicate_indels(real_be_tb, dataID)[1:ncol(real_be_tb)]
      
      #keep track of "edited" indels to filter out when extracting "unedited" alleles
      edited_alleles <- real_be_only_tb$indel
    }
    
    
    #### Filter for "real" indels (only) within entire spacer sequence and collapse by indel
    indel_only_tb <- summary_table %>% 
      filter(grepl("[+,-]", summary_table$indel) & 
               !(grepl(real_be_regexpr, summary_table$indel)))
    
    #extract the "real" indels and format the indel column
    indel_only_tb <-extract_real_indels(indel_only_tb, indel_range)
    
    real_indel_tb <- indel_only_tb %>%
      transform(indel = real_indel) %>%
      filter(is_real_indel) %>%
      select(-c("indel_idx_range", "indel_start", "indel_end", "real_indel", "is_real_indel"))
    
    #collapse alleles by indel
    if(nrow(real_indel_tb) > 0){
      real_indel_tb <- collapse_duplicate_indels(real_indel_tb, dataID)[1:ncol(real_indel_tb)]

      #keep track of "edited" indels to filter out when extracting "unedited" alleles
      edited_alleles <- c(edited_alleles, indel_only_tb$indel[which(indel_only_tb$is_real_indel)])
    }
    
    
    #### Filter for "real" indels and BE within entire spacer sequence and collapse by indel
    real_be_and_indel_tb <- summary_table %>%
      filter(grepl("[+,-]", summary_table$indel) & 
               grepl(real_be_regexpr, summary_table$indel))

    #keep track of "edited" indels to filter out when extracting "unedited" alleles
    edited_alleles <- c(edited_alleles, real_be_and_indel_tb$indel)

    #extract the "real" edits and format the indel column
    real_be_and_indel_tb <-extract_real_be_and_indels(real_be_and_indel_tb, base_edit_range, indel_range, real_be_regexpr)
    
    real_be_and_indel_tb <- real_be_and_indel_tb %>%
      transform(indel = gsub("^, ", "", 
                             gsub(", $", "", paste(real_be, real_indel, sep = ", ")))) %>%
      select(-c("indel_idx_range", "indel_start", "indel_end", "real_indel", "is_real_indel", "real_be", "potential_be", "be_idx", "real_be_idx")) %>%
      filter(indel != "")
  
    #collapse alleles by indel
    if(nrow(real_be_and_indel_tb) > 0){
      real_be_and_indel_tb <- collapse_duplicate_indels(real_be_and_indel_tb, dataID)[1:ncol(real_be_and_indel_tb)]
    }

    #bind tables of "true" edits together
    real_edit_tb <- rbind(rbind(real_be_tb, real_indel_tb), real_be_and_indel_tb) %>%
      transform( indel = trimws( indel, which = "both"))
    
    #collapse alleles by indel
    if(nrow(real_edit_tb) > 0){
      real_edit_tb <- collapse_duplicate_indels(real_edit_tb, dataID)[1:ncol(real_edit_tb)]
    }

    names(real_edit_tb) <- gsub("^X", "", names(real_edit_tb))


    #get table of "false" edits and unedited percentages and sum the percentages to generate
    # total unedited percentage
    unedited_tb <- summary_table[! (summary_table$indel %in% edited_alleles), ]

    unedited_tb[1, vars_select(names(unedited_tb), contains(dataID))] <- unedited_tb %>%
      select(vars_select(names(unedited_tb),contains(dataID))) %>%
      colSums(na.rm = TRUE)

    #bind unedited and edited tables together
    real_alleles_tb <- rbind(unedited_tb[1,], real_edit_tb)
    real_alleles_tb <- adjust_percent_frequency(real_alleles_tb, dataID)

    #save as .csv
    BE_conversion <- paste("Cto", gsub("[[:punct:]]", "", target_nucleotides), sep = "")
    save_to_csv(real_alleles_tb, ".", paste(csv_prefix,"BE_summary", BE_conversion, sep = "_"))
  }
  
  #end summary run log
  cat("\n")
}

###### extract_real_be_results() #############################################################################
# For CRISPResso2 outputs from base editor samples. Assumes the CRISPResso quantification window
# covers the entire spacer sequence.
# This function takes the real_be_only_tb table, which contains all alleles containing no indels and all potential
# ref_nucleotide --> target_nucleotide conversions. The function filters the substitutions so that only the 
# ref_nucleotide --> target_nucleotide conversions within the base_edit_range of spacer bp indexes are included.
#
# ARGUMENTS:  real_be_only_tb = collapsed allele table containing all alleles containing no indels and all potential
#                               ref_nucleotide --> target_nucleotide conversions
#             base_edit_range = two-index vector base editing quantification window (beginning, end)
#             real_be_regexpr = regular expression for searching for potential BE results (ex: C[0-9][T])
#
# OUTPUT: returns allele table with columns ready to filter for accepted BE results
extract_real_be_results <- function(real_be_only_tb, base_edit_range, real_be_regexpr){
  
  #extract the "real" base edits and format the indel column
  real_be_tb <- real_be_only_tb %>%
    mutate(potential_be = regmatches(real_be_only_tb$indel, 
                                gregexpr(real_be_regexpr, real_be_only_tb$indel))) %>%
    mutate(be_idx = mapply(function(x) as.numeric(unlist(regmatches(x, gregexpr("[0-9]{1,}", x)))), 
                           potential_be))
  
  real_be_tb$real_be_idx <- mapply(function(x) c(which(x >= base_edit_range[1] & x <= base_edit_range[2])),
                                   real_be_tb$be_idx)
  real_be_tb$real_be <- mapply(function(x, y) paste(x[y], sep = " ", collapse = " "),
                             real_be_tb$potential_be, real_be_tb$real_be_idx)

  return(real_be_tb)
}

###### extract_real_indels () #############################################################################
# For CRISPResso2 outputs from base editor samples. Assumes the CRISPResso quantification window
# covers the entire spacer sequence.
# This function takes the indel_only_tb table, which contains all alleles containing indels with no correct
# ref_nucleotide --> target_nucleotide conversions. The function filters the indels so that only the 
# indels within the indel_range of spacer bp indexes are included.
#
# ARGUMENTS:  indel_only_tb = collapsed allele table containing all alleles containing indels with no correct
#                               ref_nucleotide --> target_nucleotide conversions
#             indel_range = two-index vector indel quantification window (beginning, end)
#
# OUTPUT: returns allele table with columns ready to filter for accepted indels
extract_real_indels <- function(indel_only_tb, indel_range){
  
  #extract the "real" indels and format the indel column
  indel_only_tb <- indel_only_tb %>%
    transform(real_indel = regmatches(indel_only_tb$indel, 
                                 regexpr("[+,-][0-9]{1,} ([[:print:]]{1,})", 
                                         indel_only_tb$indel))) %>%
    mutate(indel_idx_range = trimws(gsub("(?<=[0-9])-", "_",
                                         gsub("[[:alpha:]]{1, }", "", 
                                              gsub("[-,+]{1}[0-9]{1,} \\(", "",
                                                   gsub("\\)", "", real_indel, perl = TRUE))), 
                                         perl = TRUE))) %>%
    separate(col = indel_idx_range, into = c("indel_start", "indel_end"), sep = "_", remove = FALSE) %>%
    transform(indel_start = as.numeric(indel_start),
              indel_end = as.numeric(ifelse(is.na(indel_end), indel_start, indel_end))) %>%
    mutate(is_real_indel = ifelse((indel_start <= indel_range[2] & as.numeric(indel_end) >= indel_range[1]), TRUE,
                               ifelse((indel_start %in% indel_range & indel_end %in% indel_range), TRUE, FALSE)))
  return(indel_only_tb)
}

###### extract_real_indels () #############################################################################
# For CRISPResso2 outputs from base editor samples. Assumes the CRISPResso quantification window
# covers the entire spacer sequence.
# This function takes the real_be_and_indel_tb, which contains all alleles containing both indels AND potential
# ref_nucleotide --> target_nucleotide conversions. The function filters the indels so that only the 
# indels within the indel_range of spacer bp indexes AND the ref_nucleotide --> target_nucleotide conversions 
# within the base_edit_range of spacer bp indexes are included.
#
# ARGUMENTS:  real_be_and_indel_tb = collapsed allele table containing all alleles containing indels AND potential
#                               ref_nucleotide --> target_nucleotide conversions
#             base_edit_range = two-index vector base editing quantification window (beginning, end)
#             indel_range = two-index vector indel quantification window (beginning, end)
#             real_be_regexpr = regular expression for searching for potential BE results (ex: C[0-9][T])
#
# OUTPUT: returns allele table with columns ready to filter for accepted indel+BE combination alleles
extract_real_be_and_indels <- function(real_be_and_indel_tb, base_edit_range, indel_range, real_be_regexpr){
  
  #extract real BE results
  be_extracted_tb <- extract_real_be_results(real_be_and_indel_tb, base_edit_range, real_be_regexpr)
  
  #extract real indels (set real_indel as "" if !is_real_indel)
  be_indel_extracted_tb <- extract_real_indels(be_extracted_tb, indel_range) %>%
    transform(real_indel = ifelse(is_real_indel, as.character(real_indel), ""))
  
  return(be_indel_extracted_tb)
}
